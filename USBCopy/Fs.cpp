#include "StdAfx.h"
#include "Fs.h"


#pragma pack(push,1)
/****************************************************************************
*     分区表项结构(16字节)
****************************************************************************/
typedef struct _STRUCT_PARTITION_ENTRY
{
	UCHAR BootIndicator;  // 能否启动标志
	UCHAR StartHead;   // 该分区起始磁头号
	UCHAR StartSector;  // 起始柱面号高2位：6位起始扇区号
	UCHAR StartCylinder;  // 起始柱面号低8位
	UCHAR PartitionType;  // 分区类型
	UCHAR EndHead;   // 该分区终止磁头号
	UCHAR EndSector;   // 终止柱面号高2位：6位终止扇区号
	UCHAR EndCylinder;  // 终止柱面号低8位
	ULONG StartLBA;   // 起始扇区号
	ULONG TotalSector;  // 分区尺寸（总扇区数）
}PARTITION_ENTRY,*PPARTITION_ENTRY;

/****************************************************************************
*     主引导记录(MBR)结构 
****************************************************************************/
typedef struct _STRUCT_MASTER_BOOT_RECORD
{
	UCHAR    BootCode[446];
	PARTITION_ENTRY  Partition[4];
	USHORT    Signature;
}MASTER_BOOT_RECORD,*PMASTER_BOOT_RECORD;

#pragma pack(pop)

#define LODWORD(_qw)    ((DWORD)(_qw))
#define HIDWORD(_qw)    ((DWORD)(((_qw) >> 32) & 0xffffffff))

Fs::Fs()
{
	m_hDisk = INVALID_HANDLE_VALUE;
	m_dwErrorCode = 0;
	m_dwClusterSize = 8 * 512; //4KB
	m_dwBytesPerSector = 512;
	m_ullSectorNum = 0;
	
	memset(&m_DiskGeometry,0,sizeof(DISK_GEOMETRY_EX));
	memset(m_szVolumeLable,0,sizeof(m_szVolumeLable));

	memset(&m_ReadOverlap,0,sizeof(OVERLAPPED));
	memset(&m_WriteOverlap,0,sizeof(OVERLAPPED));

	m_ReadOverlap.hEvent = CreateEvent(NULL,FALSE,TRUE,NULL);
	m_WriteOverlap.hEvent = CreateEvent(NULL,FALSE,TRUE,NULL);

	ASSERT(m_ReadOverlap.hEvent && m_WriteOverlap.hEvent);
}


Fs::~Fs(void)
{
	if (m_ReadOverlap.hEvent)
	{
		CloseHandle(m_ReadOverlap.hEvent);
	}

	if (m_WriteOverlap.hEvent)
	{
		CloseHandle(m_WriteOverlap.hEvent);
	}
}

BOOL Fs::Init(HANDLE hDisk,DWORD dwClusterSize,const char* lpszVolumeLable)
{
	m_hDisk = hDisk;

	DWORD junk;
	BOOL bResult;
	bResult = DeviceIoControl(m_hDisk, 
		IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, 
		NULL, 
		0, 
		&m_DiskGeometry, 
		sizeof(m_DiskGeometry), 
		&junk, 
		NULL);

	if (!bResult)
	{
		m_dwErrorCode = GetLastError();
		return FALSE;
	}

	m_dwBytesPerSector = m_DiskGeometry.Geometry.BytesPerSector;
	m_ullSectorNum = m_DiskGeometry.DiskSize.QuadPart / m_dwBytesPerSector;

	m_dwClusterSize = dwClusterSize;
	
	strcpy_s(m_szVolumeLable,lpszVolumeLable);

	return TRUE;
}

BOOL Fs::InitialDisk()
{
	const BYTE byBootInfo[446] = {
		0x33,0xC0,0x8E,0xD0,0xBC,0x00,0x7C,0x8E,0xC0,0x8E,0xD8,0xBE,0x00,0x7C,0xBF,0x00,
		0x06,0xB9,0x00,0x02,0xFC,0xF3,0xA4,0x50,0x68,0x1C,0x06,0xCB,0xFB,0xB9,0x04,0x00,
		0xBD,0xBE,0x07,0x80,0x7E,0x00,0x00,0x7C,0x0B,0x0F,0x85,0x0E,0x01,0x83,0xC5,0x10,
		0xE2,0xF1,0xCD,0x18,0x88,0x56,0x00,0x55,0xC6,0x46,0x11,0x05,0xC6,0x46,0x10,0x00,
		0xB4,0x41,0xBB,0xAA,0x55,0xCD,0x13,0x5D,0x72,0x0F,0x81,0xFB,0x55,0xAA,0x75,0x09,
		0xF7,0xC1,0x01,0x00,0x74,0x03,0xFE,0x46,0x10,0x66,0x60,0x80,0x7E,0x10,0x00,0x74,
		0x26,0x66,0x68,0x00,0x00,0x00,0x00,0x66,0xFF,0x76,0x08,0x68,0x00,0x00,0x68,0x00,
		0x7C,0x68,0x01,0x00,0x68,0x10,0x00,0xB4,0x42,0x8A,0x56,0x00,0x8B,0xF4,0xCD,0x13,
		0x9F,0x83,0xC4,0x10,0x9E,0xEB,0x14,0xB8,0x01,0x02,0xBB,0x00,0x7C,0x8A,0x56,0x00,
		0x8A,0x76,0x01,0x8A,0x4E,0x02,0x8A,0x6E,0x03,0xCD,0x13,0x66,0x61,0x73,0x1C,0xFE,
		0x4E,0x11,0x75,0x0C,0x80,0x7E,0x00,0x80,0x0F,0x84,0x8A,0x00,0xB2,0x80,0xEB,0x84,
		0x55,0x32,0xE4,0x8A,0x56,0x00,0xCD,0x13,0x5D,0xEB,0x9E,0x81,0x3E,0xFE,0x7D,0x55,
		0xAA,0x75,0x6E,0xFF,0x76,0x00,0xE8,0x8D,0x00,0x75,0x17,0xFA,0xB0,0xD1,0xE6,0x64,
		0xE8,0x83,0x00,0xB0,0xDF,0xE6,0x60,0xE8,0x7C,0x00,0xB0,0xFF,0xE6,0x64,0xE8,0x75,
		0x00,0xFB,0xB8,0x00,0xBB,0xCD,0x1A,0x66,0x23,0xC0,0x75,0x3B,0x66,0x81,0xFB,0x54,
		0x43,0x50,0x41,0x75,0x32,0x81,0xF9,0x02,0x01,0x72,0x2C,0x66,0x68,0x07,0xBB,0x00,
		0x00,0x66,0x68,0x00,0x02,0x00,0x00,0x66,0x68,0x08,0x00,0x00,0x00,0x66,0x53,0x66,
		0x53,0x66,0x55,0x66,0x68,0x00,0x00,0x00,0x00,0x66,0x68,0x00,0x7C,0x00,0x00,0x66,
		0x61,0x68,0x00,0x00,0x07,0xCD,0x1A,0x5A,0x32,0xF6,0xEA,0x00,0x7C,0x00,0x00,0xCD,
		0x18,0xA0,0xB7,0x07,0xEB,0x08,0xA0,0xB6,0x07,0xEB,0x03,0xA0,0xB5,0x07,0x32,0xE4,
		0x05,0x00,0x07,0x8B,0xF0,0xAC,0x3C,0x00,0x74,0x09,0xBB,0x07,0x00,0xB4,0x0E,0xCD,
		0x10,0xEB,0xF2,0xF4,0xEB,0xFD,0x2B,0xC9,0xE4,0x64,0xEB,0x00,0x24,0x02,0xE0,0xF8,
		0x24,0x02,0xC3,0x49,0x6E,0x76,0x61,0x6C,0x69,0x64,0x20,0x70,0x61,0x72,0x74,0x69,
		0x74,0x69,0x6F,0x6E,0x20,0x74,0x61,0x62,0x6C,0x65,0x00,0x45,0x72,0x72,0x6F,0x72,
		0x20,0x6C,0x6F,0x61,0x64,0x69,0x6E,0x67,0x20,0x6F,0x70,0x65,0x72,0x61,0x74,0x69,
		0x6E,0x67,0x20,0x73,0x79,0x73,0x74,0x65,0x6D,0x00,0x4D,0x69,0x73,0x73,0x69,0x6E,
		0x67,0x20,0x6F,0x70,0x65,0x72,0x61,0x74,0x69,0x6E,0x67,0x20,0x73,0x79,0x73,0x74,
		0x65,0x6D,0x00,0x00,0x00,0x63,0x7B,0x9A,0x00,0x00,0x00,0x00,0x00,0x00};

	MASTER_BOOT_RECORD mbr;
	memset(&mbr,0,sizeof(MASTER_BOOT_RECORD));

	memcpy(mbr.BootCode,byBootInfo,446);

	mbr.Signature = 0xAA55;

	BOOL bSuc = WriteSectors(0,1,(LPBYTE)&mbr);

	return bSuc;
}

BOOL Fs::PartitionDisk()
{
	BOOL bSuc = FALSE;
	MASTER_BOOT_RECORD mbr;
	memset(&mbr,0,sizeof(MASTER_BOOT_RECORD));

	bSuc = ReadSectors(0,1,(LPBYTE)&mbr);

	if (bSuc)
	{
		DWORD PS = m_DiskGeometry.Geometry.SectorsPerTrack;
		DWORD PH = m_DiskGeometry.Geometry.TracksPerCylinder;

		//C= LBA DIV（PH * PS）+ Cs 
		//H=LBA DIV PS–（C-Cs）* PH + Hs 
		//S=LBA–（C–Cs）* PH * PS –（H–Hs）* Ps + Ss

		//C=LBA DIV（PH*PS）+CS 
		//H=（LBA DIV PS）MOD PH+HS 
		//S=LBA MOD PS+SS

		//C/H/S 0/0/1
		mbr.Partition[0].BootIndicator = 0;
		mbr.Partition[0].StartCylinder = (UCHAR)(START_SECTOR / (PH * PS));
		mbr.Partition[0].StartHead = (UCHAR)(START_SECTOR / PS % PH);
		mbr.Partition[0].StartSector = (UCHAR)(START_SECTOR % PS + 1);

		mbr.Partition[0].PartitionType = 0x0B;
		mbr.Partition[0].StartLBA = START_SECTOR;

		mbr.Partition[0].EndCylinder = (UCHAR)(m_ullSectorNum / (PH * PS));
		mbr.Partition[0].EndHead = (UCHAR)(m_ullSectorNum / PS % PH);
		mbr.Partition[0].EndSector = (UCHAR)(m_ullSectorNum % PS + 1);

		mbr.Partition[0].TotalSector = (ULONG)(m_ullSectorNum - START_SECTOR);

		bSuc = WriteSectors(0,1,(LPBYTE)&mbr);

		if (bSuc)
		{
			BYTE *pDbr = new BYTE[512];
			memset(pDbr,0,512);

			bSuc = WriteSectors(START_SECTOR,1,pDbr);

			delete []pDbr;
		}
		
	}

	return bSuc;
}

BOOL Fs::ReadSectors( ULONGLONG ullStartSector,DWORD dwSectors,LPBYTE lpSectBuff )
{
	ULONGLONG ullOffset = ullStartSector * m_dwBytesPerSector;
	DWORD dwLen = dwSectors * m_dwBytesPerSector;
	DWORD dwReadLen = 0;
	DWORD dwErrorCode = 0;
	
	m_ReadOverlap.Offset = LODWORD(ullOffset);
	m_ReadOverlap.OffsetHigh = HIDWORD(ullOffset);

	if (!ReadFile(m_hDisk,lpSectBuff,dwLen,&dwReadLen,&m_ReadOverlap))
	{
		dwErrorCode = ::GetLastError();

		if(dwErrorCode == ERROR_IO_PENDING) // 结束异步I/O
		{
			if (WaitForSingleObject(m_ReadOverlap.hEvent, INFINITE) != WAIT_FAILED)
			{
				if(!::GetOverlappedResult(m_hDisk, &m_ReadOverlap, &dwReadLen, FALSE))
				{
					m_dwErrorCode = ::GetLastError();
					return FALSE;
				}
				else
				{
					m_dwErrorCode = 0;
					return TRUE;
				}
			}
			else
			{
				m_dwErrorCode = ::GetLastError();
				return FALSE;
			}

		}
		else
		{
			m_dwErrorCode = dwErrorCode;
			return FALSE;
		}
	}
	else
	{
		m_dwErrorCode = 0;
		return TRUE;
	}
}

BOOL Fs::WriteSectors( ULONGLONG ullStartSector,DWORD dwSectors,LPBYTE lpSectBuff )
{
	ULONGLONG ullOffset = ullStartSector * m_dwBytesPerSector;
	DWORD dwLen = dwSectors * m_dwBytesPerSector;
	DWORD dwWriteLen = 0;
	DWORD dwErrorCode = 0;

	m_WriteOverlap.Offset = LODWORD(ullOffset);
	m_WriteOverlap.OffsetHigh = HIDWORD(ullOffset);


	if (!WriteFile(m_hDisk,lpSectBuff,dwLen,&dwWriteLen,&m_WriteOverlap))
	{
		dwErrorCode = ::GetLastError();

		if(dwErrorCode == ERROR_IO_PENDING) // 结束异步I/O
		{
			if (WaitForSingleObject(m_WriteOverlap.hEvent, INFINITE) != WAIT_FAILED)
			{
				if(!::GetOverlappedResult(m_hDisk, &m_WriteOverlap, &dwWriteLen, FALSE))
				{
					m_dwErrorCode = ::GetLastError();
					return FALSE;
				}
				else
				{
					m_dwErrorCode = 0;
					return TRUE;
				}
			}
			else
			{
				m_dwErrorCode = ::GetLastError();
				return FALSE;
			}

		}
		else
		{
			m_dwErrorCode = dwErrorCode;
			return FALSE;
		}
	}
	else
	{
		m_dwErrorCode = 0;
		return TRUE;
	}
}

BOOL Fs::FormatPartition()
{
	return TRUE;
}

DWORD Fs::GetErrorCode()
{
	return m_dwErrorCode;
}
