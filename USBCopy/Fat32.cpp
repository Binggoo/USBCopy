#include "StdAfx.h"
#include "Fat32.h"
#include <time.h>

#pragma pack(push,1)
/************************************************************************/
/* 文件系统头
 * EB 3C 90 -> FAT12/16
 * EB 58 90 -> FAT32
 * EB 52 90 -> NTFS
 * EB 76 90 -> EXFAT*/
/************************************************************************/
typedef struct _STRUCT_DBR_HEAD
{
	UCHAR JmpInstruction[3];
	UCHAR OemString[8];
}DBR_HEAD,*PDBR_HEAD;

typedef struct _STRUCT_BIOS_PARAMETER_BLOCK
{
	USHORT BytesPerSector;  //每扇区字节数
	UCHAR  SectorsPerCluster;//每簇扇区数
	USHORT ReservedSectors; //保留扇区数
	UCHAR  NumOfFATs;       //FAT表个数
	USHORT RootEntries;     //根目录最多容纳目录项数 FAT32不使用
	USHORT SmallVolumeSectors;         //扇区总数，小于32M时存放此处
	UCHAR  MediaDescriptor; //介质描述符，F8
	USHORT SectorsPerFAT;   //每个FAT表大小扇区数，FAT32不使用此处
	USHORT SectorsPerTrack; //每磁道扇区数
	USHORT Heads;           //磁头数
	ULONG  HiddenSectos;    //隐藏扇区数，DBR扇区相对0号扇区偏移
	ULONG  LargeVolumeSectors;//扇区总数，大于32M时存放此
}BIOS_PARAMETER_BLOCK,*PBIOS_PARAMETER_BLOCK;

typedef struct _STRUCT_FAT32_SECTION
{
	ULONG  SectorsPerFAT; //每个FAT表大小扇区数
	USHORT ExtendFlags;   //标记，0
	USHORT Version;       //版本，0
	ULONG  RootDirStartCluster; //根目录起始簇号，通常为2
	USHORT FSInfoSector; //FSINFO 所在扇区号，通常为1号扇区
	USHORT BackupBootSector; //备份引导扇区位置，通常为6号扇区
	UCHAR  Reserved[12];
	UCHAR  BiosDrive; //BIOS Int 13H设备号 ,0x80
	UCHAR  Unused;
	UCHAR  ExtBootSign;//扩展引导标识，0x29
	ULONG  VolumeSerialNum;
	UCHAR  VolumeLable[11];//卷标
	UCHAR  FileSystem[8];  //文件系统格式ASCII FAT32
}FAT32_SECTION,*PFAT32_SECTION;

typedef struct _STRUCT_FAT32_DOS_BOOT_RECORD
{
	DBR_HEAD                  DBRHead;
	BIOS_PARAMETER_BLOCK      Bpb;
	FAT32_SECTION             Fat32Section;
	UCHAR                     BootCode[420];
	USHORT                    Signature;
}FAT32_DOS_BOOT_RECORD,*PFAT32_DOS_BOOT_RECORD;

#pragma pack(pop)

CFat32::CFat32()
{
}


CFat32::~CFat32(void)
{
}

BOOL CFat32::FormatPartition()
{
	// 第一步，填充DBR
	const BYTE byBootCode[420] = {
		0x33,0xC9,0x8E,0xD1,0xBC,0xF4,0x7B,0x8E,0xC1,0x8E,0xD9,0xBD,0x00,0x7C,0x88,0x4E,
		0x02,0x8A,0x56,0x40,0xB4,0x41,0xBB,0xAA,0x55,0xCD,0x13,0x72,0x10,0x81,0xFB,0x55,
		0xAA,0x75,0x0A,0xF6,0xC1,0x01,0x74,0x05,0xFE,0x46,0x02,0xEB,0x2D,0x8A,0x56,0x40,
		0xB4,0x08,0xCD,0x13,0x73,0x05,0xB9,0xFF,0xFF,0x8A,0xF1,0x66,0x0F,0xB6,0xC6,0x40,
		0x66,0x0F,0xB6,0xD1,0x80,0xE2,0x3F,0xF7,0xE2,0x86,0xCD,0xC0,0xED,0x06,0x41,0x66,
		0x0F,0xB7,0xC9,0x66,0xF7,0xE1,0x66,0x89,0x46,0xF8,0x83,0x7E,0x16,0x00,0x75,0x38,
		0x83,0x7E,0x2A,0x00,0x77,0x32,0x66,0x8B,0x46,0x1C,0x66,0x83,0xC0,0x0C,0xBB,0x00,
		0x80,0xB9,0x01,0x00,0xE8,0x2B,0x00,0xE9,0x2C,0x03,0xA0,0xFA,0x7D,0xB4,0x7D,0x8B,
		0xF0,0xAC,0x84,0xC0,0x74,0x17,0x3C,0xFF,0x74,0x09,0xB4,0x0E,0xBB,0x07,0x00,0xCD,
		0x10,0xEB,0xEE,0xA0,0xFB,0x7D,0xEB,0xE5,0xA0,0xF9,0x7D,0xEB,0xE0,0x98,0xCD,0x16,
		0xCD,0x19,0x66,0x60,0x80,0x7E,0x02,0x00,0x0F,0x84,0x20,0x00,0x66,0x6A,0x00,0x66,
		0x50,0x06,0x53,0x66,0x68,0x10,0x00,0x01,0x00,0xB4,0x42,0x8A,0x56,0x40,0x8B,0xF4,
		0xCD,0x13,0x66,0x58,0x66,0x58,0x66,0x58,0x66,0x58,0xEB,0x33,0x66,0x3B,0x46,0xF8,
		0x72,0x03,0xF9,0xEB,0x2A,0x66,0x33,0xD2,0x66,0x0F,0xB7,0x4E,0x18,0x66,0xF7,0xF1,
		0xFE,0xC2,0x8A,0xCA,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xF7,0x76,0x1A,0x86,0xD6,
		0x8A,0x56,0x40,0x8A,0xE8,0xC0,0xE4,0x06,0x0A,0xCC,0xB8,0x01,0x02,0xCD,0x13,0x66,
		0x61,0x0F,0x82,0x75,0xFF,0x81,0xC3,0x00,0x02,0x66,0x40,0x49,0x75,0x94,0xC3,0x42,
		0x4F,0x4F,0x54,0x4D,0x47,0x52,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x0D,0x0A,0x52,0x65,0x6D,0x6F,0x76,0x65,0x20,0x64,0x69,0x73,0x6B,0x73,
		0x20,0x6F,0x72,0x20,0x6F,0x74,0x68,0x65,0x72,0x20,0x6D,0x65,0x64,0x69,0x61,0x2E,
		0xFF,0x0D,0x0A,0x44,0x69,0x73,0x6B,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,0x0A,
		0x50,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,0x6F,
		0x20,0x72,0x65,0x73,0x74,0x61,0x72,0x74,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0xAC,
		0xCB,0xD8,0x00,0x00
	};

	FAT32_DOS_BOOT_RECORD dbr;
	memset(&dbr,0,sizeof(FAT32_DOS_BOOT_RECORD));
	dbr.DBRHead.JmpInstruction[0] = 0xEB;
	dbr.DBRHead.JmpInstruction[1] = 0x58;
	dbr.DBRHead.JmpInstruction[2] = 0x90;

	memcpy(dbr.DBRHead.OemString,"MSDOS5.0",8);

	dbr.Bpb.BytesPerSector = (USHORT)m_dwBytesPerSector;
	dbr.Bpb.SectorsPerCluster = (UCHAR)(m_dwClusterSize/m_dwBytesPerSector);
	dbr.Bpb.ReservedSectors = 0x20;
	dbr.Bpb.NumOfFATs = 2;
	dbr.Bpb.RootEntries = 0;
	dbr.Bpb.SmallVolumeSectors = 0;
	dbr.Bpb.MediaDescriptor = 0xF8;
	dbr.Bpb.SectorsPerFAT = 0;
	dbr.Bpb.SectorsPerTrack = (USHORT)m_DiskGeometry.Geometry.SectorsPerTrack;
	dbr.Bpb.Heads = (USHORT)m_DiskGeometry.Geometry.TracksPerCylinder;
	dbr.Bpb.HiddenSectos = START_SECTOR;
	dbr.Bpb.LargeVolumeSectors = (ULONG)m_ullSectorNum;

	// 计算每个FAT表扇区数
	// HiddenSectos + ReservedSectors + NumOfFATs * SectorsPerFAT 
	// + (SectorsPerFAT * BytesPerSector/4 - 2) * SectorsPerCluster = LargeVolumeSectors
	dbr.Fat32Section.SectorsPerFAT = (dbr.Bpb.LargeVolumeSectors - dbr.Bpb.ReservedSectors - dbr.Bpb.HiddenSectos + 2 * dbr.Bpb.SectorsPerCluster)
		/ (dbr.Bpb.NumOfFATs + dbr.Bpb.BytesPerSector * dbr.Bpb.SectorsPerCluster / 4);

	dbr.Bpb.ReservedSectors += (dbr.Bpb.LargeVolumeSectors - dbr.Bpb.ReservedSectors - dbr.Bpb.HiddenSectos + 2 * dbr.Bpb.SectorsPerCluster)
		% (dbr.Bpb.NumOfFATs + dbr.Bpb.BytesPerSector * dbr.Bpb.SectorsPerCluster / 4);

	dbr.Fat32Section.RootDirStartCluster = 2;
	dbr.Fat32Section.FSInfoSector = 1;
	dbr.Fat32Section.BackupBootSector = 6;

	dbr.Fat32Section.BiosDrive = 0x80;
	dbr.Fat32Section.ExtBootSign = 0x29;
	dbr.Fat32Section.VolumeSerialNum = (ULONG)time(NULL);
	memcpy(dbr.Fat32Section.VolumeLable,m_szVolumeLable,11);
	memcpy(dbr.Fat32Section.FileSystem,"FAT32",5);

	memcpy(dbr.BootCode,byBootCode,420);

	dbr.Signature = 0xAA55;

	// 第二步，把保留扇区先清零
	DWORD dwSetors = dbr.Bpb.ReservedSectors + dbr.Fat32Section.SectorsPerFAT * dbr.Bpb.NumOfFATs;
	DWORD dwLen = dwSetors * m_dwBytesPerSector;
	BYTE *pByte = new BYTE[dwLen];
	memset(pByte,0,dwLen);
	if (!WriteSectors(START_SECTOR,dwSetors,pByte))
	{
		delete []pByte;
		pByte = NULL;

		return FALSE;
	}

	delete []pByte;
	pByte = NULL;

	// 第三步，填充DBR 和 备份DBR
	if (!WriteSectors(START_SECTOR,1,(LPBYTE)&dbr))
	{
		return FALSE;
	}

	if (!WriteSectors(START_SECTOR + dbr.Fat32Section.BackupBootSector,1,(LPBYTE)&dbr))
	{
		return FALSE;
	}

	// 第四步，填写FSINFO
	pByte = new BYTE[512];
	memset(pByte,0,512);
	memcpy(pByte,"RRaA",4);
	memcpy(pByte+0x1E4,"rrAa",4);
	*((ULONG *)(pByte + 0x1E8)) = 0xFFFFFFFF;
	*(pByte + 0x1EC) = 2;
	*((USHORT *)(pByte + 0x1FE)) = 0xAA55;

	if (!WriteSectors(START_SECTOR + 1,1,pByte))
	{
		delete []pByte;
		pByte = NULL;

		return FALSE;
	}

	memset(pByte,0,512);
	*((USHORT *)(pByte + 0x1FE)) = 0xAA55;

	if (!WriteSectors(START_SECTOR + 2,1,pByte))
	{
		delete []pByte;
		pByte = NULL;

		return FALSE;
	}

	

	// 第五步，写FAT表
	BYTE byFATHead[12] = {0xF8,0xFF,0xFF,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F};
	memset(pByte,0,512);
	memcpy(pByte,byFATHead,12);
	if (!WriteSectors(START_SECTOR + dbr.Bpb.ReservedSectors,1,byFATHead))
	{
		delete []pByte;
		pByte = NULL;
		return FALSE;
	}

	if (!WriteSectors(START_SECTOR + dbr.Bpb.ReservedSectors + dbr.Fat32Section.SectorsPerFAT,1,byFATHead))
	{
		delete []pByte;
		pByte = NULL;
		return FALSE;
	}

	delete []pByte;
	pByte = NULL;

	// 第六步，写根目录
	dwLen = dbr.Bpb.SectorsPerCluster * dbr.Bpb.BytesPerSector;
	pByte = new BYTE[dwLen];
	memset(pByte,0,dwLen);

	memcpy(pByte,m_szVolumeLable,11);
	*(pByte + 0x0B) = 0x08;

	WORD  wYmd = 0,wHms = 0;
	int year,month,day,hour,minute,second;
	CTime time = CTime::GetCurrentTime();

	year = time.GetYear() - 1980;
	month = time.GetMonth();
	day = time.GetDay();
	hour = time.GetHour();
	minute = time.GetMinute();
	second = time.GetSecond();

	wHms |= (second & 0x1F);
	wHms |= ((minute << 5) & 0x7E0);
	wHms |= ((hour << 11) & 0xF800);

	wYmd |= (day & 0x1F);
	wYmd |= ((month << 5) & 0x1E0);
	wYmd |= ((year << 9) & 0xFE00);

	*((PWORD)(pByte + 0x16)) = wHms;
	*((PWORD)(pByte + 0x18)) = wYmd;

	if (!WriteSectors(START_SECTOR + dbr.Bpb.ReservedSectors + dbr.Fat32Section.SectorsPerFAT * 2,dbr.Bpb.SectorsPerCluster,pByte))
	{
		delete []pByte;
		pByte = NULL;

		return FALSE;
	}

	delete []pByte;
	pByte = NULL;

	return TRUE;

}

